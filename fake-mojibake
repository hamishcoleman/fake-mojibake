#!/usr/bin/env perl
use warnings;
use strict;

use Data::Dumper;
$Data::Dumper::Indent = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Quotekeys = 0;

use IO::File;
use IO::Poll qw(POLLIN);

my $db;

sub conv_load {
    my $table = shift;

    my $fh = IO::File->new($table) || die "open table $table $!";

    my $partial;
    while (<$fh>) {
        chomp;
        s/^\s+//; # no whitespace at start
        s/#.*//;  # remove comments (TODO - escaped hash chars)
        s/\s+$//; # no whitespace at end

        next if (!$_);  # skip empty lines

        if (m/^\{/) {
            if (defined($partial)) {
                die("Nested open braces are invalid");
            }
            $partial = {};
            next;
        }
        if (!defined($partial)) {
            die("Definitions cannot be outside a brace block");
        }

        if (m/^\}/) {
            if (!defined($partial->{name})) {
                die("No name for definition block");
            }
            push @{$db->{order}}, $partial->{name};
            $db->{conv}{$partial->{name}} = $partial;
            $partial = undef;
            next;
        } 

        if (m/^name\s*"(.+)"$/) {
            $partial->{name} = $1;
            next;
        }

        if (m/^map "(.+)"\s+"(.+)"$/) {
            $partial->{map}{$1} = $2;
            next;
        }
    }
}

# Convert a single char of input
sub conv_char {
    my $db = shift;
    my $from = shift;

    die if (!defined($from));
    die if (length($from)>1);

    for my $table (@{$db->{order}}) {
        my $map = $db->{conv}{$table}{map}{$from};
        if (defined($map)) {
            return($map);
        }
    }

    # no match
    return undef;
}

# returns either: the bytes waiting, empty string on timeout or undef on error
sub maybe_slirp {
    my $fh = shift;
    my $timeout = shift;

    my $poll = IO::Poll->new();
    $poll->mask($fh => POLLIN);

    my $poll_result = $poll->poll($timeout);
    if ($poll_result<0) {
        # an error
        return undef;
    }

    if ($poll_result==0) {
        # no events waiting - must be a timeout
        return '';
    }

    my $buf;
    my $count = $fh->sysread($buf,1);
    if ($count == 0) {
        # some error, punt
        return undef;
    }
    return $buf;
}

sub process_handle {
    my $db = shift;
    my $fh = shift;

    # make output unbuffered
    $| = 1;

    my $state = 'none';
    while (1) {
        my $buf = maybe_slirp($fh,0.1);

        if (!defined($buf)) {
            # errors or end of file
            return;
        }

        if (length($buf)==0) {
            # timeout
            next;
        }

        if ($state eq 'none') {
            if ($buf eq "\e") {
                # this is the start of an escape sequence
                print($buf);
                $state = 'esc';
                next;
            }

            my $to = conv_char($db,$buf);
            if (defined($to)) {
                print($to);
            } else {
                print($buf);
            }
        }

        if ($state eq 'esc') {
            # FIXME - assume always at least one char after escape
            print($buf);

            if ($buf eq ']') {
                # its a xterm title sequence
                $state = 'title';
                next;
            }

            # FIXME - assume sequence ends with first alpha char
            if ($buf =~ m/[a-zA-Z]/) {
                $state = 'none';
            }
        }

        if ($state eq 'title') {
            print($buf);
            # title sequence ends with a bel char
            if ($buf eq "\007") {
                $state = 'none';
            }
        }
    }
}

sub main() {
    for my $table (@ARGV) {
        conv_load($table);
    }


    # if debug
    #   print(Dumper($db));

    my $stdin = \*STDIN;
    process_handle($db,$stdin);
}
main();
