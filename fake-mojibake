#!/usr/bin/env perl
use warnings;
use strict;

use Data::Dumper;
$Data::Dumper::Indent = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Quotekeys = 0;

use IO::File;
use IO::Poll qw(POLLIN);

my $db;

sub conv_load {
    my $table = shift;

    my $fh = IO::File->new($table) || die "open table $table $!";

    my $partial;
    while (<$fh>) {
        chomp;
        s/^\s+//; # no whitespace at start
        s/#.*//;  # remove comments (TODO - escaped hash chars)
        s/\s+$//; # no whitespace at end

        next if (!$_);  # skip empty lines

        if (m/^\{/) {
            if (defined($partial)) {
                die("Nested open braces are invalid");
            }
            $partial = {};
            next;
        }
        if (!defined($partial)) {
            die("Definitions cannot be outside a brace block");
        }

        if (m/^\}/) {
            if (!defined($partial->{name})) {
                die("No name for definition block");
            }
            push @{$db->{order}}, $partial->{name};
            $db->{conv}{$partial->{name}} = $partial;
            $partial = undef;
            next;
        } 

        if (m/^name\s*"(.+)"$/) {
            $partial->{name} = $1;
            next;
        }

        if (m/^map "(.+)"\s+"(.+)"$/) {
            $partial->{map}{$1} = $2;
            next;
        }
    }
}

# Convert a single char of input
sub conv_char {
    my $db = shift;
    my $from = shift;

    die if (!defined($from));
    die if (length($from)>1);

    for my $table (@{$db->{order}}) {
        my $map = $db->{conv}{$table}{map}{$from};
        if (defined($map)) {
            return($map);
        }
    }

    # no match
    return undef;
}

# for now, simply process words as if they were single chars
sub conv_word {
    my $db = shift;
    my $word = shift;

    my $result;
    for my $ch (split(//,$word)) {
        my $to = conv_char($db,$ch);
        if (defined($to)) {
            $result .= $to;
        } else {
            $result .= $ch;
        }
    }
    return $result;
}

sub process_buf {
    my $db = shift;
    my $buf = shift;
    my $state = $db->{state};

    my $result;
    my $word;
    for my $ch (split(//,$buf)) {
        if ($state eq 'word') {
            if ($ch =~ m/\w/) {
                $word .= $ch;
                next;
            }

            # this char is not a word char, thus ending the word
            $result .= conv_word($db,$word);
            $word = undef;

            # fall through and process this char
            $state = 'none';
        }

        if ($state eq 'none') {
            if ($ch eq "\e") {
                # this is the start of an escape sequence
                $result .= $ch;
                $state = 'esc';
                next;
            }

            if ($ch =~ m/\w/) {
                $state = 'word';
                $word .= $ch;
                next;
            }

            # neither escape, nor word char, append an fall through
            $result .= $ch;
            next;
        }

        if ($state eq 'esc') {
            # FIXME - assume always at least one char after escape
            $result .= $ch;

            if ($ch eq ']') {
                # its a xterm title sequence
                $state = 'title';
                next;
            }

            # FIXME - assume sequence ends with first alpha char
            if ($ch =~ m/[a-zA-Z]/) {
                $state = 'none';
            }
        }

        if ($state eq 'title') {
            $result .= $ch;
            # title sequence ends with a bel char
            if ($ch eq "\007") {
                $state = 'none';
            }
        }
    }

    if ($state eq 'word') {
        # flush partial words
        $result .= conv_word($db,$word);
        $state = 'none';
    }
    $db->{state} = $state;
    return $result;
}

# returns either: the bytes waiting, empty string on timeout or undef on error
sub maybe_slirp {
    my $fh = shift;
    my $timeout = shift;

    my $poll = IO::Poll->new();
    $poll->mask($fh => POLLIN);

    my $poll_result = $poll->poll($timeout);
    if ($poll_result<0) {
        # an error
        return undef;
    }

    if ($poll_result==0) {
        # no events waiting - must be a timeout
        return '';
    }

    my $result;
    while ($poll->poll(0.01)) {
        my $buf;
        my $count = $fh->sysread($buf,4096);
        if ($count == 0) {
            # some error, punt
            return undef;
        }
        $result .= $buf;
    }
    return $result;
}

sub process_handle {
    my $db = shift;
    my $fh = shift;

    # make output unbuffered
    $| = 1;

    $db->{state} = 'none';
    while (1) {
        my $buf = maybe_slirp($fh,0.1);

        if (!defined($buf)) {
            # errors or end of file
            return;
        }

        if (length($buf)==0) {
            # timeout
            next;
        }

        print(process_buf($db,$buf));
    }
}

sub main() {
    for my $table (@ARGV) {
        conv_load($table);
    }


    # if debug
    #   print(Dumper($db));

    my $stdin = \*STDIN;
    process_handle($db,$stdin);
}
main();
